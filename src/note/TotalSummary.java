package note;

public class TotalSummary {

	/* ☆★☆1. 상수와 변수★☆★
	 * *. 변수
	 * -데이터를 저장하기 위한 공간
	 * -값이 바뀔 수 있다
	 * -변수의 선언 방식
	 * 	-자료형 변수명 = 초기값;
	 * -기본 자료형 -> 
	 * 	정수 : byte, short, int, long, 
	 * 		-> long에는 리터럴 상수 접미사 l이 필요
	 * 	실수 : float, double(소수점 자리가 다름=> 정확도와 표현범위가 다름) 
	 * 		-> float에는 리터럴 상수 접미사 f가 필요
	 * 	문자 : char(2byte)=> 언어마다 문자 자료형의 크기가 다름
	 * 	논리 : boolean
	 * 	
	 * -자료형 형변환
	 *  -변수/상수의 자료형을 일시적으로 변환
	 *  -자동 형변환
	 *  	-정수 => 실수
	 *  	-작은 바이트 => 큰 바이트
	 *  -강제 형변환(명시적 형변환)
	 *  	-자동으로 안되는 경우
	 *  	-자동형변환이 가능하지만 상황에 따라서 필요에 의해 강제로 하는 경우도 있음 cf) /연산
	 *  -변수명 작성 규칙
	 *  	-숫자가 첫 글자가 될 수 없음
	 *  	-특수문자는 _,$만 가능
	 *  	-변수명 중복 선언 불가
	 *  	-대소문자는 구별됨
	 *  	-필드와 지역변수는 중복 가능 => 필드는 this. 를 통해 지역변수와 구분하여 접근이 가능
	 *  	
	 *  -변수명 작성 관례
	 *  	-카멜 표기법 : 시작은 소문자로 하되 합성어의 경우 두번쨰 단어부터 첫글자를 대문자로 사용
	 *  	-변수명은 의미있게 사용 => 무식한거 존나 시룸 ><
	 * *. 상수
	 * -리터럴 상수
	 *  -1,'1',"1",true
	 *  -리터럴 상수는 저장 공간이 따로 있어서 리터럴 상수가 언급이 되면 그때 사용
	 *  -문자열인 경우 같은 리터럴 문자열을 저장하는 문자열 객체들은 같은 주소를 공유
	 *  cf) String str1 = "hi";
	 *  	String str2 = "hi"; //str1과 str2는 같은 주소를 저장함
	 *  
	 * -상수 변수
	 *  -변수 앞에 final 키워드가 붙어서 상수취급
	 *  -상수는 값이 바뀔 수 없다.
	 *  -지역 변수인 상수는 반드시 선언과 동시에 초기화를 해줘야 함
	 *  -필드로 상수가 선언되면 생성자로 초기화가 가능함
	 *  
	 *  -변수의 종료
	 *  	-지역 변수 : 메소드 안에서 선언 된 변수, 메소드를 빠져 나가면 사라짐
	 *  	-필드 : 클래스의 멤버 변수
	 *  	-매개 변수 : 메소드를 실행할 때 필요한 변수들, 메소드를 빠져 나가면 사라짐
	 *  	-참조 변수 : 객체, 열거형 등을 저장하는 변수, 기본 자료형이 아닌 변수
	 *  	-클래스 변수 : static이 붙은 필드, 동일한 클래스의 객체들이 공유하는 변수 => 클래스의 생성과 함께 생성되는 변수임
	 *  		-> static이 붙는 경우 클래스를 통해 호출 cf) Math.random()
	 *  		-> static이 붙지 않는 경우 객체를 통해 호출
	 *  	-인스턴스(객체)변수 : static이 안 붙은 필드, 객체마다 필드가 존재
	 *  	
	 *  
	 *  -매개변수와 인자
	 *  	-매개변수 => 메소드 선언부에 있는 변수
	 *  	-인자 => 메소드 호출시 넘겨주는 값
	 * */
	
	/* 연산자
	 * -대입연산자 = : 오른쪽 값을 왼쪽에 저장 => ==와 혼동하지 말것
	 * -산술연산자 + - * / % 
	 * 	-정수 연산자 정수 => 정수 cf) 1/2 => 0
	 * 	- /와 %는 두번째 피연산자가 0이면 안됨
	 * -비교연산자 : 크기 비교
	 * 	-주의사항 없음
	 * 	-비교연산자의 결과 값은 boolean 비교 연산자가 들어간 식은 조건식이 됨
	 * -논리연산자 : &&, ||, ! => 조건식에 사용
	 * -증감연산자
	 * 	-전위 : 증가하고 동작
	 * 	-후위 : 동작하고 증가
	 * -조건선택 연산자 => 코드가 깔끔해짐 조건식 ? 참 : 거짓;
	 * 
	 * */
	
	/* 조건식
	 * -조건에 따라 결과가 달라질 때 조건식을 사용함
	 * -if문
	 * 	-모든 조건식은 if문으로 표현가능
	 * -switch문
	 * 	-연산 결과의 경우의수가 한정적일때 사용하면 if문보다 간결함
	 * 	-값에는 문자, 정수, 문자열만 가능
	 * 
	 * */
	
	/* 반복문
	 * -반복적인 작업을 규칙적으로 할 때
	 * =>반복횟수, 규칙성
	 * =>반복횟수=> 초기화 + 조건식 +증감싱
	 * =>규칙성 => 실행문
	 * 
	 * 0, 2, 4, 6, 8, 10
	 * */
	
	/*배열
	 * -같은 타입의 변수들을 모아놓은것 
	 * -배열은 참조변수, 주소를 저장
	 * ->할당된 배열이 있는 0번지의 주소를 저장
	 * */
	
	/*메소드
	 * -하나의 기능을 모아놓은 코드
	 * -입력정보 : 매개변수, 출력정보 : 리턴타입
	 * -매개변수 : 메소드를 실행하기 위해 꼭 필요한 정보
	 * */
	
	/*접근 제한자
	 * -private : 나
	 * -default : 나+같은패키지
	 * -protected : 나+같은패키지+자식클래스
	 * -public : 전부
	 * 
	 * */
	/*클래스
	 * 캡슐화, 상속, 다형성
	 * 다형성 - 부모클래스의 객체로 다양한 자식 클래스의 객체를 관리할 수 있는것
	 * */
	/*static 메소드
	 * 인스턴스 메소드
	 * */
	
	/*상속
	 * -부모클래스의 필드/메소드를 물려받는것
	 * -접근 제한자의 따라 접근하지 못하는 필드/메소드도 있음
	 * -자식 클래스는 부모클래스가 1개*/
	
	/*메소드 오버라이딩
	 * -부모클래스에 있는 메소드를 재정의 하는것
	 * -메소드명의 동일
	 * -매개변수 갯수와 타입이 동일
	 * -접근제한자는 부모클래스의 메소드보다 같거나 넓어야함
	 * =>부모클래스의 메소드가 public이면 자식이 오버라이딩 할때 private으로 설정 불가능
	 * */
	
	/*this는 클래스 자신을 참조하는 변수
	 * super는 부모클래스의 객체를 참조하는 변수
	 * this()는 클래스 자신의 다른 생성자를 호출
	 * super()는 부모클래스의 생성자를 호출
	 * */
	/*클래스의 형변환
	 * 자동 : 자식 클래스의 객체를 부모 클래스의 참조변수가 관리
	 * 부모클래스 객체 A = new 자식클래스 생성자();
	 *  -객체 A는 부모클래스에 있는 메소드는 다 사용 가능
	 *  -객체 A는 자식클래스에 있는 메소드는 그냥 사용 불가
	 *  => ((자식클래스명)객체A)메소드();
	 * 
	 * 강제 : 부모클래스의 객체를 자식 클래스의 참조변수가 관리하는 경우 아래와 같은 경우만 가능
	 * 부모클래스 객체 B = new 자식클래스생성자();
	 * 자식클래스 객체C = (자식클래스)객체B;
	 * 
	 * */
	
	/*기본 API
	 * -래퍼클래스
	 *  -기본자료형을 클래스로 만듬
	 *  -byte => Byte, short => Short, int =>Integer, long => Long
	 *  -char=>Character
	 *  -float=>Float,double=>Double
	 *  	=> 제네릭 클래스는 <>안에 클래스명이 필요하므로 기본 자료형을 사용할 수 없음
	 * 	-박싱 : 기본자료형을 래퍼클래스의 객체로 만듬
	 * 	-언박싱 : 래퍼클래스의 객체를 기본자료형으로 만듬
	 *
	 * 
	 * -String 
	 * 	-문자열 클래스
	 * 	-String 객체에 값을 수정하면 문자열이 교체
	 * cf) String str= "123"; str="1234"; 문자열 123을 추가하는것이 아니라 1234라는 문자열을 새로만드는것
	 * 	-length():문자열의 길이
	 * 	-substring(int start, int end): start부터 end-1까지 문자열을 뽑아옴
	 *  -chartAt(int index) : index번지에 있는 문자열을 가져옴
	 *  -split(구분자) : 구분자를 기준으로 문자열들을 추출하여 문자열 배열을 리턴
	 *  -indexOf("문자열") : 문자열이 있으면 시작번지, 없으면 -1리턴
	 *  -toUppercase() : 문자열을 대문자로
	 *  -toLowercase() : 문자열을 소문자로
	 *  
	 *  -Date
	 *  -날짜정보 관리
	 * 
	 * -Math
	 * 	-min(int num1, int num2) : 작은수를 리턴
	 *  -max(int num1, int num2) : 큰수를 리턴 
	 *  -abs(int num) :절대값
	 *  -round(double num) : 소숫점 첫째자리에서 반올림
	 *  -floor(double num) : 소수점 첫쨰자리에서 버림
	 *  -ceil(double num) :올림
	 *  -pow(a,b) : a의 b제곱
	 *  -sqrt(a) : 루트 a
	 *  
	 *  -StringTokenizer : 구분자를 기준으로 문자열을 가져와서 확인을 해줌
	 *  -split과 유사
	 *  -countTokens() : 현재 토큰의 개수
	 *  -hasMoreTokens() : 토큰이 더 있는지 boolean값으로 리턴
	 *  -nextToken(): 다음 토큰
	 *  
	 *  -Object
	 *   -모든 클래스의 최상위 조상 클래스 => 모든 클래스는 Object의 메소드를 오버라이딩 할 수 있음
	 *   
	 *   -equals():
	 *   	-Object클래스의 equals는 주소가 같은 객체인 경우만 true
	 *   	-객체의 필드들이 같더라도 같은 주소의 객체가 아니면 false
	 *   	-오버라이딩을 이용하여 필드가 같으면 같은 객체로 판별하도록 작성
	 *   	-toString():
	 *   -패키지명과 클래스명과 주소가 나옴
	 *   
	 *   
	 *   추상 메소드
	 *   -구현부가 없는 메소드
	 *   -키워드로 abstract가 필요
	 *   -추상 메소드에는 반드시 abstract를 추가해야함
	 *   
	 *   인터페이스
	 *   -추상메소드와 클래스상수필드(final static)으로 구성
	 *   -메소드에 abstract를 생략해도 자동으로 추가됨 +public
	 *   -구현 클래스를 생성한후 추상메소드를 오버라이딩하고 객체를 생성
	 *   
	 *   예외처리
	 *   -직접처리
	 *   -try~catch
	 *   -예외 클래스2는 예외클래스1의 자손이 아니어야함
	 *   -예외 던지기
	 *   -throw
	 *   ->조건문과 같이 사용
	 *   ->throw new 예외클래스명(예외메시지);
	 *   -throw를 이용하는 경우 메소드에 예외가 발생할 수 있다는것을 표시
	 *   ->매개변수 옆에 표시
	 *   ->RuntimeException이거나 자손이면 생략, 아니면 불가
	 *   
	 *   
	 *   컬렉션 프레임워크
	 *   -데이터를 효율적으로 관리학 ㅣ위한 것
	 *   -컬렉션
	 *   	-공통
	 *   	-add 요소추가
	 *   	-remove 요소제거
	 *   -리스트
	 *   -셋
	 *   -맵
	 * */
	
}