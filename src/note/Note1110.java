package note;

public class Note1110 {
	/*배열
	 * -같은 자료형의 데이터들을 모아놓은 것
	 * -반복문을 사용하여 데이터들을 편하게 관리하기 위해서 사용함.
	 * -배열 선언 방법
	 * 자료형 [] 배열명, 자료형 배열명[] = new 자료형 [크기]
	 * -할당된 배열 각 번지는 자료형에 맞는 초기값으로 초기화가 된다.
	 * -시작번지는 0번지, 마지막번지는 크기-1
	 * -배열 arr에 i번지에 있는 값을 접근 : arr[i]
	 * 
	 * 클래스
	 * -하나의 정보를 표현하기 위해서 여러 변수들과 기능들을 모아놓은 것
	 * -필드, 메소드, 생성자
	 * -필드 : 객체를 나타내기 위해서 공통적이고 필수적으로 요구되는 정보와 속성
	 * 		-필드는 일반적으로 접근 제한자가 private => getter/setter가 요구됨
	 * -메소드 : 필요한 기능, 대부분 필드 값을 변경되게 하는 기능
	 * 		-필드는 일반적으로 접근 제한자가 public
	 * -생성자 : 필드 생성값의 초기화
	 * 
	 * 접근제한자
	 * -private		:나	 
	 * -(default)	:나 + 같은 내의 클래스패키지
	 * -protected 	:나 + 같은 패키지 내의 클래스 + 자식 클래스
	 * -public		:나 + 같은 패키지 내의 클래스 + 자식 클래스 + 외부 클래스
	 * 
	 * 같은 이름의 클래스는 존재할 수 없다
	 * 	-같은 패키지내에서는 존재 할 수 없다
	 * 	-다른 패키지에서는 존재 할 수 있다.
	 * 
	 * public 클래스가 되기 위한 조건
	 * -클래스명과 파일명이 동일한 경우
	 * 
	 * 필드 
	 * 	-클래스 필드  : static이 포함됨
	 * 		-클래스가 메모리에 올라오면 필드들이 할당
	 * 		-객체들이 클래스 필드를 공유
	 * 		초기화 순서
	 * 		1.필드의 기본값으로 초기화
	 * 		2.명시적 초기화(선언과 동시에 초기화)
	 * 		3.초기화 블록(static{}안에 있는)	  
	 * 	-인스턴스 필드 : static이 포함되지않음
	 *		-객체가 생성될 때 필드들이 할당
	 *		-객체마다 인스턴스 필드를 가지고 있음
	 * 	 	초기화 순서
	 * 		1.필드의 기본값으로 초기화
	 * 		2.명시적 초기화(선언과 동시에 초기화)
	 * 		3.초기화 블록({}안에 있는)	 
	 * 		4. 생성자
	 * 
	 * -클래스필드/메소드
	 * 	-클래스 메소드에서 사용 가능
	 * 	-인스턴스 메소드에서 사용 가능
	 * 
	 * -인스턴스필드/메소드
	 * 	-인스턴스 메소드에서 사용 가능
	 * 	-클래스 메소드에서 사용 불가
	 * 		-직접 사용은 불가능하지만 객체를 생성 후에 사용하는것은 가능
	 * ex) class A{
	 * 				public void testA(){}
	 * 				public static void Testb(){ testA;//에러 발생
	 * 					A a = new A();
	 * 					a.testA();"}
	 * 
	 * 상속
	 * -부모 클래스의 필드/메소드를 물려받아 자식 클래스가 활용하는 것
	 * -접근제한자가 private인 필드/미소드는 직접 접근해서 사용할 수 없다.
	 * 
	 * 상속하는 이유
	 * -코드의 중복을 제거
	 * -다형성을 이용하여 메소드 중복을 제거
	 * 
	 * class 자식클래스명 extedns 부모클래스명{
	 * }
	 * 
	 *	class에서 부모는 몇개? => 1개
	 *	인터페이스에서 부모 인터페이스는 몇개? => 여러개
	 *
	 *	다형성 : 하나의 객체가 여러가지 타입을 가질 수 있는 것
	 *	매개변수의 다형성
	 *  public void 전원(TV a){}
	 *  public void 전원(에어컨 b){}
	 *  public void 전원(컴퓨터 c){}
	 *  => public void 전원(전자제품을 ovj)
	 *  =>매개변수로 여러 객체들이 올 수 있는다.
	 * 이때 매개변수로 오는 객체들이 동일한 조상 클래스의 자식 클래스들인 경우,
	 *  매개변수를 조상 클래스의 객체로 선언하면 여러 메소드를 만들 필요가 없다.
	 *   
	 *	객체의 다형성 
	 *	Tv tv1, tv2, tv3;
	 *	콤퓪타 com1, com2, com3;
	 *	에어컨 에어컨1;
	 * 	=> 위의 코드에서는 다양한 클래스의 객체들을 하나로 관리 하는 것이 불가능하다.
	 * 전자제품 [] ;
	 * 
	 * 클래스 형변환
	 * -자동
	 * 	-자식객체를 부모 객체에 저장하는 경우.
	 * -강제
	 * 	-부모객체를 자식 객체에 저장하는 경우 (조건부로만 가능)
	 * 	-부모 객체와 연결된 객체가 자식 클래스의 객체인 경우 클래스 변환이 가능.
	 * 	-부모 객체와 연결된 객체가 부모 클래스의 객체 인 경우에는 클래스 변환이 불가능
	 * 
	 * instanceof : 클래스 변환이 가능한지 불가능한지 알려주는 연산자
	 * 		-true/false로 결과문이 출력되며 조건문과 함께 활용
	 * 
	 * 인터페이스
	 * -추상메소드와 클래스 상수로만 이루어진 것
	 * -기능에 대한 표준화
	 * 
	 * 추상 메소드
	 * -메소드 구현부가 없는 메소드
	 * -기능을 사용하려면 메소드 오버라이딩을 통해 기능 구현 후에 호출
	 * 
	 * 구현 클래스 : 인터페이스를 구현한 클래스
	 * -인터페이스에 있는 메소드들을 반드시 오버라이딩 해야함
	 * -구현 클래스는 여러 인터페이스를 구현할 수 있다.
	 * 
	 * class A implements InterfaceA, InterfaceB{}
	 * -구현 클래스 A는 inerfaceA, interfaceB를 구현한 구현 클래스
	 * 
	 * 상속과 구현은 같이 할 수 있다
	 * 
	 * class Child extends Parent implements InerfaceA{}
	 * 
	 * String 클래스
	 * -indexOf(), equals(), contains(), length(), subString(), split()
	 * 
	 * Object 클래스
	 * -equals(), toString()
	 * 
	 * Wrapper 클래스 :기본 자료형을 클래스로 만든것
	 * int => Integer
	 * boolean => Boolean
	 * char => Character
	 * double => Double
	 * */
	
	/*예외처리
	 * 
	 * 프로그램 오류
	 * 프로그램 수행 시 치명적 상황이 발생하여 비정상 종료 상황이 발생한 것
	 * 
	 * 컴파일에러 : 소스상의 문법에러=>소스구문수정
	 * 런타임에러 : 입력값이 틀린경우 => if문 사용
	 * 시스템 에러 : 컴퓨터 오작동으로 인한 에러
	 * 
	 * 예외 => 소스수정으로 구문해결이 가능한 에러를 구문으로 미리 처리해두는것
	 * 
	 * 예외 클래스 계층 구조
	 * Exception과 Error모두 Object 클래스의 자손이며 모든 예외의 최고조상은 
	 * Exception - Checked Exception => 반드시 예외처리 해주어야함
	 * Unchecked Exception => 코드상의 예외표시는 나지 않지만 실행시에 오류가 남
	 * 
	 * RuntimeException
	 * =>프로그래머 부주의에 의한 오류가 다수, 예외처리보다는 코드수정
	 * ArithmeticException : 나눗셈을 0으로 진행, if문으로 나누는수가 0인지 검사
	 * NullPointException : null참조변수로 객체 멤버 참조 시도시 발생, 
	 * NegativeArraySizeException : 배열 크기를 음수로 지정한 경우
	 * ArrayIndexOutOfBoundsException : 배열의 범위가 벗어난 경우
	 * ClssCastException : Cast연산자 타입오류
	 * 
	 * 예외처리방법
	 * 
	 * 1.Exception이 발생한 곳에서 직접 처리
	 * try~catch문
	 * try : exception 발생 가능성이 있는 코드를 기술
	 * catch : try구문에서 exception 발생시 해당하는 exception에 대한 처리를 기술
	 * finally : exception 발생 여부와 관계없이 꼭 처리해하는 로직을 기술, 여러가지 exception 처리가 가능하나 상속관계 처리
	 *  ** 중간에 return문을 만나도 finally구문은 실행되지만 System.exit();를 만나면 무조건 프로그램이 종료됨
	 *
	 * 
	 * 2.Exception처리를 호출한 메소드에게 위임
	 * 메소드 선언시 throws ExceptionName문을 추가하여 호출한 상위 메소드에게 처리 위임
	 * */
}
