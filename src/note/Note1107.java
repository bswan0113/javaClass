package note;

public class Note1107 {
	/* String 클래스는 문자열의 값을 수정할 수 없음.
	 * StringBuffer 클래스는 문자열의 값을 수정 할 수 있음.
	 * StringBuilder 클래스는 StringBuffer와 동일함
	 * StringBuffer는 쓰레드에서 safe기능을 제공하고, StringBuilder는 제공하지 않음
	 * */
	
	/* length() : 문자열의 길이
	 * indexOf() : 해당 문자열/문자가 있는 위치를 0번지부터 탐색하여 위치가 첫번째로 시작하는 번지
	 * lastIndexOf() : indexOf()와 같으나 마지막번지부터 탐색
	 * contains(문자열 또는 문자) 해당 문자열/ 문자의 존재 여부를 알려줌
	 * subString(시작번지) :문자열의 시작번지부터 끝까지 부분 문자열을 추출
	 * subString(시작번지, 마지막번지) : 문자열의 시작번지부터 마지막번지 -1까지 부분문자열을 추출
	 * equals(문자열) : 문자열과 같은지 다른지를 비교하여 알려줌
	 * 문자열은 참조변수이기 때문에 ==를 통해서는 정확히 같은지 다른지를 비교할 수 없음.
	 *  참조변수 비교시 ==는 같은 객체를 비교할때에만 사용 가능
	 *  리터럴 문자열은 리터럴들만 모여있는 공간에 할당이 되는데, 같은 리터럴 문자열이 있는 경우
	 *  새로 만들지 않고 기존에 있는 리터럴 문자열의 주소를 반환
	 *  charAt(index) : 문자열에서 해당 번지에 있는 문자열을 반환
	 *  split(정규표현식) : 정규표현식을 기준으로 문자열을 추출하여 배열로 만듬
	 *  trim() : 시작 문자 앞에 있는 공백을 제거하고 마지막 문자 뒤에 있는 공백을 제거
	 * */
	
	/*	상속 
	 * 	-다른 클래스가 가지고 있는 멤버들을새로 작성할 클래스에서 직접 만들지않고 새 클래스가 자신의 멤버처럼 사용할 수 있는기능
	 * 	-상속의 목적 => 클래스의 재사용, 일련의 클래스들에 대한 공통적인 규약정의
	 * 	-상속의 장점 
	 * 		- 보다 적은 양의 코드로 새로운 클래스 작성 가능
	 * 		- 코드를 공통적으로 관리하기때문에 코드의 추가 및 변경 용이
	 * 		- 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여
	 * 
	 * 	-상속의 특징
	 * 		-모든 클래스는 Object클래스의 후손
	 * 			-Object클래스가 제공하는 메소드를 오버라이딩하여 재구현 가능
	 * 		-부모 클래스의 생성자, 초기화 블록은 상속되지않음
	 * 			-자식 클래스 생성시 부모클래스 생성자가 먼저 실행
	 * 			-자식 클래스 안에서 부모클래스 생성자 호출을 명시하고 싶으면 super()활용
	 * 		-부모의 private멤버는 상속은 되지만 접근 불가
	 * 			-getter,setter또는 super를 통해 접근
	 * 
	 * 		방법 => extends 키워드 사용
	 * 
	 * 		[접근제한자] class 클래스명 extends 클래스명
	 * 
	 * 		단일 상속 => 자바에서는 클래스간 다중상속 미지원 => 부모클래스가 하나임
	 * 
	 * 	A(자식) is a B(부모)로 표현이 가능할때 상속을 함
	 * 	ex)스마트폰은 폰이다 => O
	 * 		스마트폰은 카메라이다 => X
	 * 		폰은 스마트폰이다 => X
	 * 		현대차는 자동차이다 => O
	 * A has a B로 표현을 가능하면 포함을 한다. => B가 A클래스에 필드로선언
	 * 
	 * 	super()
	 * 		- 부모 객체의 생성자를 호출하는 메소드
	 * 		-부모 생성자를 호출하는 super()를 첫줄에 존재
	 * 		-
	 * 		
	 * 	super.
	 * 
	 * 	오버라이딩
	 * 		-자식클래스가 상속받은 부모메소드를 재작성하는것
	 * 		-부모가 제공하는 기능을 일부 고쳐 사용
	 * 		-자식 객체를 통한 실행시 자식것이 우선권을 가짐
	 * 		-메소드 헤드라인위에 AnnoTation, @Override 표시
	 * 		-접근제어자를 부모보다 넓거나 같은 범위로 변경가능
	 * 		-부모 메소드의 예외처리 클래스 처리범위보다 좁은 범위로 예외처리 클래스 수정가능
	 * 		-메소드 이름, 매개변수의 개수, 타입, 리턴타입 동일
	 * 		-private메소드 오버라이딩 불가 => 직접접근 불가
	 * 
	 * 	final
	 * 		-final 클래스는 상속 및 오버라이딩이 불가능함
	 * 
	 * */
	
	/*	다형성
	 * 	-여러개의 형태를 갖는다는 의미
	 * 	-하나의 행동으로 여러가지 일을 수행하는 개념
	 *  -상속을 이용한 기술로 부모타입으로부터 파생된 여러가지 타입의 자식객체를 부모 클래스타입 하나로 다룰 수 있는 기술
	 *  
	 *  클래스형변환
	 *   - 업캐스팅 : 상속관계에 있는 부모, 자식 클래스간에 부모타입의 참조형 변수가 모든 지식타입의 객체 주소를 받을 수 있음
	 *   	ex) car c = new Sonata(); 
	 *   		자식의 객체를 부모에 저장
	 *   - 다운캐스팅 : 자식 객체의 주소를 받은 부모 참조형 변수를 가지고 자식의 멤버를 참조해야 할 경우 부모클래스 타입의
	 *   참조형 변수를 자식 클래스타입으로 형 변환 하는것
	 *   		ex) Car c = new sonata();
	 *   			((sonata)c).moveSonata();
	 *   		부모의 객체를 자식에 저장 // 조건부로 가능(업캐스팅한 부모객체를, 다시 자식객체로 다운캐스팅 할경우)
	 * */
	
	/*
	 * instanceof
	 *  : 현재 참조형 변수가 어떤 클래스형의 객체 주소를 참조하고 있는지 확인 할 때 사용 // 형변환 가능 여부 확인
	 *  if (래퍼런스 instanceof 클래스타입){
	 *  			true일때 처리할 내용, 해당클래스타입으로 downcasting}
	 * */
	
	/* 매개변수와 다형성
	 * 	- 다형성을 이용하여 메소드 호출시 부모타입의 변수 하나만 사용해 자식타입의 객체를 받을 수 있음.
	 * 
	 * */
	
}